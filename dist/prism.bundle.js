!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.prism=e():t.prism=e()}(self,()=>(()=>{"use strict";var t={d:(e,r)=>{for(var s in r)t.o(r,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:r[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{AsyncSearch:()=>m,ConvergingRun:()=>w,PopRace:()=>y,Run:()=>a,Search:()=>d});class r{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return i.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return i.along(this,t=>t.parent)}}class s extends r{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new s).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new s(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new i;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let s=this;for(;0<t;)r[t-1]=e(s.last),s=s.prev,t--;return r}}class o{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),o.as((...r)=>i.equal(t,r)?e:void 0)}static as(t){if(t instanceof o)return t;if("function"!=typeof t){const e=t;t=t=>t===e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,o.prototype),e.what=t,e}if(t=t=>void 0!==t){return o.if(this,t)}static if(t,e=t=>void 0!==t){return o.as(r=>o.what(e,r)?o.what(t,r):void 0)}sthen(t){return o.sthen(this,t)}static sthen(...t){return o.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=r instanceof Promise?r.stthen(e):o.what(e,r)}return r})}else(t){return o.else(this,t)}static else(...t){return o.as(e=>{let r;for(let s of t){try{r=o.what(s,e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return o.which(this,t)}static which(t,e=t=>void 0!==t){return o.as(r=>i.as(o.what(t,r)).which((t,s)=>e(t,s,r)))}when(t,e=!0,r=e){return o.when(this,t,e,r)}static when(t,e,r=!0,s=r){const n="number"==typeof e;return o.as((...a)=>{const h=n?e:(t,r)=>o.what(e,t,r,...a);return i.as(o.what(t,...a)).when(h,r,s)})}match(...t){return o.match(this,...t)}static match(...t){const e=t.length<2?e=>{const r=o.what(t[0],e);return r[Symbol.iterator]?i.as(r).sthen(t=>[e,t]):[e,r]}:e=>t.map(t=>o.what(t,e));return o.as(e)}each(t){return o.as((...e)=>{const r=new i,s=i.as(this.what(...e)).which();return r[Symbol.iterator]=function*(){for(let e of s)for(let r of i.as(o.what(t,e)).which())yield r},r})}static each(...t){return o.as(e=>{const r=e instanceof s?e:s.of(e);return r.length>t.length?i.of():r.across(i.as(o.what(t[r.length-1],r.last)).which()).which()})}self(t=void 0,e=void 0){return o.self(this,t,e)}static self(t,e=void 0,r=void 0){let s;return s=void 0===e?void 0===r?e=>e.across(i.as(o.what(t,e.last)).which()):(...e)=>{const s=o.what(t,...e);if(void 0===s)return;const n={};return n[r]=s,n}:"number"==typeof e?(...s)=>{const n=s.splice(e,0,r);return o.what(t,...n)}:s=>{const n=i.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?s[t]:t),a=o.what("string"==typeof t?s[t]:t,...n);if(void 0!==a)return void 0!==r?(s[r]=a,s):a},o.as(s)}static what(t,...e){return t instanceof o?t.what(...e):"function"==typeof t?t(...e):t}}class n{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new n;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof n)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new n;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new n;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return n.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return n.equal(this,t)}static along(t,e){const r=new n;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await o.what(e,r)},r}static async equal(t,e){const r=n.as(t)[Symbol.asyncIterator](),s=n.as(e)[Symbol.asyncIterator]();for(;;){const[t,e]=await Promise.all([r.next(),s.next()]);if(t.done||e.done)return t.done===e.done;if(t.value instanceof n||e.value instanceof n){if(!await n.equal(t.value,e.value))return!1}else if(t.value!==e.value)return!1}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new n;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const s of e)await t(s,r++)&&(yield s)},r}sthen(t){const e=this,r=new n;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const s of e)yield await t(s,r++)},r}else(t=void 0){return void 0===t?n.else(this):n.else([this,n.as(t)])}static else(t){const e=new n;return e[Symbol.asyncIterator]=async function*(){for await(const e of n.as(t)){const t=n.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return n.when(this,t,e,r)}static when(t,e,r=!0,s=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},n.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const i=new n;return i[Symbol.asyncIterator]=r?async function*(){let r=0,n=!1;for await(const i of t)n?yield i:await o.what(e,i,r)&&(n=!0,s&&(yield i)),r++}:async function*(){let r=0,n=!1;for await(const i of t){if(n)break;await o.what(e,i,r)?(n=!0,s&&(yield i)):yield i,r++}},i}match(t=void 0){return void 0===t?n.match(this):n.match(this,n.as(t))}static match(...t){const e=new n,r=t.map(t=>n.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return n.each(...this);const e=this,r=new n;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of n.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>n.as(t));return o.as(t=>{if(t.length>=e.length)return n.of();const r=e[t.length],s=new n;return s[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},s})}self(){return n.self(this)}static self(t){const e=n.as(t),r=new n;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}what(t,e){return n.what(this,t,e)}static async what(t,e,r){const s=n.as(t);if(e){let t=void 0!==r;for await(const n of s)t?r=await o.what(e,r,n):(r=n,t=!0);return r}for await(const t of s)return t}}class i{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return i.of();if(t instanceof i)return t;if(t[Symbol.iterator]){const e=new i;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new i;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new i;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new i;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=o.what(e,r)},r}toArray(){return Array.from(this)}equals(t){return i.equal(this,t)}static equal(t,e){if("string"==typeof t||!i.isIterable(t)||"string"==typeof e||!i.isIterable(e))return t===e;{const r=t[Symbol.iterator](),s=e[Symbol.iterator]();for(;;){const t=r.next(),e=s.next();if(t.done||e.done)return t.done===e.done;if(!i.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return i.if(this,t)}static if(t,e=t=>void 0!==t){return i.which(t,e)}sthen(t){return i.sthen(this,t)}static sthen(t,e){const r=new i;return r[Symbol.iterator]=function*(){let r=0;for(let s of t)yield o.what(e,s,r++)},r}else(t=void 0){return void 0===t?i.else(this):i.else(i.of(this,i.as(t)))}static else(t){const e=new i;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return i.which(this,t)}static which(t,e=t=>void 0!==t){const r=new i;return r[Symbol.iterator]=function*(){let r=0;for(let s of t)o.what(e,s,r++)&&(yield s)},r}when(t,e=!0,r=e){return i.when(this,t,e,r)}static when(t,e,r=!0,s=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},n.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const a=new i;return a[Symbol.iterator]=r?function*(){let r=0,n=!1;for(let i of t)n?yield i:o.what(e,i,r)&&(n=!0,s&&(yield i)),r++}:function*(){let r=0,n=!1;for(let i of t){if(n)break;o.what(e,i,r)?(n=!0,s&&(yield i)):yield i,r++}},a}match(t=void 0){return void 0===t?i.match(...this):i.match(this,i.as(t))}static match(...t){const e=new i;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return i.each(...this);const e=this,r=new i;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of i.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),o.as(e=>e.length<t.length?e.across(t[e.length]):i.of())}self(){return i.self(this)}static self(t){const e=new i;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return i.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=i.what(t),t=i.when(t,1));for(let s of t)r=o.what(e,r,s);return r}for(let e of t)return e}}i.NATURAL=new i,i.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class a extends o{run(){throw new Error("Abstract method 'run()' must be implemented by subclasses.")}what(){return this.run()}}class h extends i{constructor(){super()}n(){throw new Error("Abstract method: n()")}has(t){throw new Error("Abstract method: has(item)")}add(t){throw new Error("Abstract method: add(item)")}remove(t){throw new Error("Abstract method: remove(item)")}clear(){throw new Error("Abstract method: clear()")}get(t){throw new Error("Abstract method: get(query)")}[Symbol.iterator](){throw new Error("Abstract method: Symbol.iterator()")}create(t){return!this.has(t)&&this.add(t)}read(t){return this.has(t)?i.as(this.get(t)).what():void 0}readAll(t){return this.get(t)}update(t,e,r=!1){return this.has(t)?this.remove(t)&&this.add(e):!!r&&this.add(e)}delete(t){return this.remove(t)}deleteAll(t){return this.removeAll(t)}query(t){return this.get(t)}isEmpty(){return 0===this.n()}let(t){return this.add(t),this}addAll(t){const e=[];for(const r of t)this.add(r)&&e.push(r);return this}removeAll(t){const e=[];for(const r of t)this.remove(r)&&e.push(r);return e}}Symbol.asyncIterator;class c extends h{constructor(){super()}peek(t=!0){throw new Error("Abstract method: peek() must be implemented by subclass.")}poll(t=!0){throw new Error("Abstract method: poll() must be implemented by subclass.")}reverse(){throw new Error("Abstract method: reverse() must be implemented by subclass.")}select(t,e=!0){t<0&&(t=0);const r=this.n()-t,s=new Array(r<0?0:r).fill(void 0);let o=e?s.length-1:0;const n=e?-1:1;for(;this.n()>t;){const t=this.poll(!e);s[o]=t,o+=n}return s}}class l extends c{constructor(t=!0,e=[]){super(),this._fifo=t,this._items=e}get fifo(){return this._fifo}get items(){return this._items}n(){return this.items.length}has(t){return!1}add(t){return this.items.push(t),!0}remove(t){return!1}peek(t=!0){return this.items[this.index(t)]}poll(t=!0){return 0===this.index(t)?this.items.shift():this.items.pop()}index(t){return this.fifo?t?0:this.items.length-1:t?this.items.length-1:0}clear(){this.items.length=0}[Symbol.iterator](){return this.items[Symbol.iterator]()}reverse(){const t=new i,e=this;return t[Symbol.iterator]=function*(){let t=e.items.length-1;for(;t>=0;)yield e.items[t],t--},t}}const u=(t,e)=>t===e?0:t<e?-1:e<t?1:0;class f extends l{constructor(t=u,e=[]){super(!0,[]),this._comparator=t,this._items=[];for(const t of e)this.add(t)}get items(){return this._items}get comparator(){return this._comparator}has(t){const[e,r]=f.logSearch(t,this.items,this.comparator);return void 0!==r}add(t){const[e,r]=f.logSearch(t,this.items,this.comparator);return void 0===r&&(this.items.splice(e,0,t),!0)}remove(t){const[e,r]=f.logSearch(t,this.items,this.comparator);return void 0!==r&&(this.items.splice(e,1),!0)}static logSearch(t,e,r,s=0,o=e.length){for(;s<o;){const n=s+o>>>1,i=r(e[n],t);if(0===i)return[n,e[n]];i<0?s=n+1:o=n}return[s,void 0]}}class d extends i{start;space;queue;max;constructor(t=void 0,e=void 0,r=new l,s=256){super(),this.start=t,this.space=e,this.queue=r,this.max=s}from(t){return this.start=t,this}through(t){return this.space=t,this}via(t,e=void 0){return this.queue=t,void 0!==e&&(this.max=e),this}*[Symbol.iterator](){const t=this.queue,e=this.space,r=i.as(this.start),s=this.max;for(t.clear(),t.addAll(r);t.n()>0;){const r=t.poll();let o;try{o="function"==typeof e?e(r):void 0}catch(t){throw new Error(`Search expansion failed at item: ${r}\n${t}`)}void 0!==o&&(t.addAll(i.as(o)),void 0!==s&&t.select(s)),yield r}}}class m extends n{start;space;queue;max;cores;constructor(t=void 0,e=void 0,r=new l,s=256,o=16){super(),this.start=t,this.space=e,this.queue=r,this.max=s,this.cores=o}from(t){return this.start=t,this}through(t){return this.space=t,this}via(t,e=void 0){return this.queue=t,void 0!==e&&(this.max=e),this}inParallel(t){return this.cores=t,this}async resolveCores(){let t="number"==typeof this.cores?this.cores:await this.cores();return Math.max(1,t)}async*batchIterator(){const t=this.queue,e=this.space,r=this.start,s=this.max;for(t.clear(),t.addAll(await n.as(r).toArray());t.n()>0;){const r=await this.resolveCores(),o=t.select(t.n()-r,!1);let i;try{i=(await n.as(await Promise.all(o.map(e))).toArray()).flat()}catch(t){throw new Error(`AsyncSearch expansion failed at batch: ${JSON.stringify(o)}\n${t}`)}t.addAll(i),void 0!==s&&t.select(s),yield o}}async*[Symbol.asyncIterator](){for await(const t of this.batchIterator())for(const e of t)yield e}}class y extends a{constructor(t,e,r,s,o){super(),this._pop=t,this._generator=r,this._partitioner=s,this._comparator=o,this._popSize=e,this._map=new Map,this._map.set(void 0,t),this._ranking=new f(o)}get pop(){return this._pop}get popSize(){return this._popSize}get generator(){return this._generator}get partitioner(){return this._partitioner}get comparator(){return this._comparator}get map(){return this._map}get ranking(){return this._ranking}run(){this._ranking.clear();let t=0;for(;this._map.size>0;){const e=new Map;for(let[,r]of this._map.entries()){r=r.sort(this.comparator).slice(0,this.popSize);for(const s of i.as(r)){this._ranking.add(s);for(const r of i.as(o.as(this._generator).what(s,t))){const s=o.as(this._partitioner).what(r,t);let n=e.get(s);n||(n=new Array,e.set(s,n)),n.push(r)}}}this._ranking.select(this.popSize),this._map.clear(),this._map=e,t++}return this}static ofChoices(t,e,r,o=16){return t=[...t,null],new y([new s],o,r=>r.across(t).which(e),t=>t.last,(t,e)=>-(r(t)-r(e)))}static ofMatches(t,e,r,s=16){throw new Error("not implemented yet")}}class w extends a{constructor(t,e,r){super(),this._start=t,this._stepper=e,this._convergenceChecker=r,this._result=t}get start(){return this._start}get result(){return this._result}get stepper(){return this._stepper}get convergenceChecker(){return this._convergenceChecker}get hasConverged(){const t=o.what(this.stepper,this._result);return o.what(this.convergenceChecker,this._result,t)}run(t){let e=this._result;for(let r=0;r<t;r++){const t=o.what(this.stepper,e);if(o.what(this.convergenceChecker,e,t))break;e=t}return this._result=e,this}}return e})());