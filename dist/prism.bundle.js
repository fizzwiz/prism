!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.prism=e():t.prism=e()}(self,()=>(()=>{"use strict";var t={7:t=>{var e,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var s=Number.isNaN||function(t){return t!=t};function i(){i.init.call(this)}t.exports=i,t.exports.once=function(t,e){return new Promise(function(r,n){function s(r){t.removeListener(e,i),n(r)}function i(){"function"==typeof t.removeListener&&t.removeListener("error",s),r([].slice.call(arguments))}p(t,e,i,{once:!0}),"error"!==e&&function(t,e){"function"==typeof t.on&&p(t,"error",e,{once:!0})}(t,s)})},i.EventEmitter=i,i.prototype._events=void 0,i.prototype._eventsCount=0,i.prototype._maxListeners=void 0;var o=10;function a(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function c(t){return void 0===t._maxListeners?i.defaultMaxListeners:t._maxListeners}function h(t,e,r,n){var s,i,o,h;if(a(r),void 0===(i=t._events)?(i=t._events=Object.create(null),t._eventsCount=0):(void 0!==i.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),i=t._events),o=i[e]),void 0===o)o=i[e]=r,++t._eventsCount;else if("function"==typeof o?o=i[e]=n?[r,o]:[o,r]:n?o.unshift(r):o.push(r),(s=c(t))>0&&o.length>s&&!o.warned){o.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=t,l.type=e,l.count=o.length,h=l,console&&console.warn&&console.warn(h)}return t}function l(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function u(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},s=l.bind(n);return s.listener=r,n.wrapFn=s,s}function f(t,e,r){var n=t._events;if(void 0===n)return[];var s=n[e];return void 0===s?[]:"function"==typeof s?r?[s.listener||s]:[s]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(s):d(s,s.length)}function y(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function d(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}function p(t,e,r,n){if("function"==typeof t.on)n.once?t.once(e,r):t.on(e,r);else{if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,function s(i){n.once&&t.removeEventListener(e,s),r(i)})}}Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(t){if("number"!=typeof t||t<0||s(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");o=t}}),i.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},i.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||s(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},i.prototype.getMaxListeners=function(){return c(this)},i.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var s="error"===t,i=this._events;if(void 0!==i)s=s&&void 0===i.error;else if(!s)return!1;if(s){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var c=i[t];if(void 0===c)return!1;if("function"==typeof c)n(c,this,e);else{var h=c.length,l=d(c,h);for(r=0;r<h;++r)n(l[r],this,e)}return!0},i.prototype.addListener=function(t,e){return h(this,t,e,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(t,e){return h(this,t,e,!0)},i.prototype.once=function(t,e){return a(e),this.on(t,u(this,t,e)),this},i.prototype.prependOnceListener=function(t,e){return a(e),this.prependListener(t,u(this,t,e)),this},i.prototype.removeListener=function(t,e){var r,n,s,i,o;if(a(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0===--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(s=-1,i=r.length-1;i>=0;i--)if(r[i]===e||r[i].listener===e){o=r[i].listener,s=i;break}if(s<0)return this;0===s?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,s),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,o||e)}return this},i.prototype.off=i.prototype.removeListener,i.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0===--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var s,i=Object.keys(r);for(n=0;n<i.length;++n)"removeListener"!==(s=i[n])&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},i.prototype.listeners=function(t){return f(this,t,!0)},i.prototype.rawListeners=function(t){return f(this,t,!1)},i.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):y.call(t,e)},i.prototype.listenerCount=y,i.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}}},e={};function r(n){var s=e[n];if(void 0!==s)return s.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};r.r(n),r.d(n,{AsyncSearch:()=>d,PopRace:()=>E,Run:()=>i,Search:()=>y});var s=r(7);class i extends s.EventEmitter{constructor(){super()}run(){throw new Error(`Abstract method "run()" must be implemented in ${this.constructor.name}.`)}}class o{parent;last;length;constructor(t=void 0,e=void 0){this.parent=t,this.last=e,this.length=t?t.length+1:void 0!==e?1:0}static of(...t){return(new o).along(t)}isEmpty(){return 0===this.length}isRoot(){return void 0===this.parent}add(t){return new o(this.isEmpty()?void 0:this,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new f;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){t=Math.min(t,this.length);const r=new Array(t);let n=this;for(;t>0;)r[t-1]=e(n.last),n=n.parent,t--;return r}}class a{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new a;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){let e;return void 0===t?a.of():t instanceof a?t:(t[Symbol.iterator]||t[Symbol.asyncIterator]?(e=new a,e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e}):(e=new a,e[Symbol.asyncIterator]=async function*(){yield await t}),e)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return a.equal(this,t)}static along(t,e){const r=new a;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!f.isIterable(t)&&!a.isAsyncIterable(t)||"string"==typeof e||!f.isIterable(e)&&!a.isAsyncIterable(e))return t===e;{const r=a.as(t)[Symbol.asyncIterator](),n=a.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await a.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new a;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new a;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?a.else(this):a.else([this,a.as(t)])}static else(t){const e=new a;return e[Symbol.asyncIterator]=async function*(){for await(const e of a.as(t)){const t=a.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return a.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},a.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new a;return s[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const i of t)s?yield i:await e(i,r)&&(s=!0,n&&(yield i)),r++}:async function*(){let r=0,s=!1;for await(const i of t){if(s)break;await e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},s}match(t=void 0){return void 0===t?a.match(this):a.match(this,a.as(t))}static match(...t){const e=new a,r=t.map(t=>a.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return a.consume(this);const e=this,r=new a;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of a.as(t))yield[r,e]},r}static async consume(t){for await(const e of t);}static each(...t){const e=t.map(t=>a.as(t));return u.as(t=>{if(t.length>=e.length)return a.of();const r=e[t.length],n=new a;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return a.self(this)}static self(t){const e=a.as(t),r=new a;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return a.what(this,t,e)}static async what(t,e,r){const n=a.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class c{static matches(t,e){if("function"==typeof e)try{return e(t)}catch(t){return!1}if(null==t)return!1;if(t===e)return!0;if(t instanceof Error)return this.matches(t.constructor.name,e)||this.matches(t.statusCode,e)||this.matches(t.message,e);if("string"==typeof t){if("string"==typeof e)return t.includes(e);if(e instanceof RegExp)return e.test(t)}return!1}}class h extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class l{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return l.as(async(...t)=>await a.equal(e,t)?r:void 0)}static as(t){if(t instanceof l)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,l.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t,e=void 0){return l.retype(l.if(t,this,e),this)}static if(t,e,r=void 0){return l.as(async(...n)=>{if(await t(...n))return await e(...n);throw r})}sthen(...t){return l.retype(l.sthen(this,...t),this)}static sthen(...t){return l.as(async e=>{let r=e;for(let e of t)r=await e(r);return r})}else(t,e=void 0){return t=l.as(t),l.retype(async(...r)=>{let n;try{n=await this(...r)}catch(n){if(!e||c.matches(n,e))return await t(...r,n);throw n}return void 0===n?await t(...r):n},this)}which(t=async t=>void 0!==t,e=void 0){return l.retype(l.which(this,t,e),this)}static which(t,e=async t=>void 0!==t,r=void 0){return l.as(async(...n)=>{const s=await t(...n);if(await e(s,...n))return s;if(void 0!==r)throw r})}when(t,e,r,n=void 0,s=!0){return l.when(t,this,e,r,n,s)}static when(t,e,r,n,s,i=!0){const o=l.as(async(...o)=>(i||e(...o),new Promise((o,a)=>{let c;const l=async(...n)=>{try{await t(...n,r)&&(u(),e.stopped=!i,i?o(await e(...n,r)):o())}catch(t){u(),a(t)}},u=()=>{c&&clearTimeout(c),"function"==typeof r.off?r.off(n,l):"function"==typeof r.removeEventListener&&r.removeEventListener(n,l)};if("function"==typeof r.on)r.on(n,l);else{if("function"!=typeof r.addEventListener)throw new Error("Unsupported emitter type");r.addEventListener(n,l)}s>0&&(c=setTimeout(()=>{u(),a(new h(`Event "${n}" timed out after ${s}ms`))},s))})));return Object.defineProperty(o,"stopped",{get:()=>e.stopped,set:t=>e.stopped=t}),o}match(...t){return l.retype(l.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return l.as(e)}each(t){return l.retype(async(...e)=>await a.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return l.as(async e=>{const r=e instanceof o?e:o.of(e);return r.length>t.length?f.of():r.across(await a.as(await l.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(...t){return l.retype(l.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=async e=>e.across(await a.as(await t(e.last)).which().toArray()),l.as(r);if("number"!=typeof e[0]){const[r,n]=e;return l.nominal(t,r,n)}if(1===e.length)return l.within(e[0],t);if(2===e.length){const[r,n]=e;return l.partial(t,r,n)}return l.retry(t,...e)}static partial(t,e,r){return l.as(async(...n)=>t(...n.slice(0,e),r,...n.slice(e)))}static nominal(t,e,r){let n;return n=void 0===e?async(...e)=>{const n=await t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:async n=>{const s=await a.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t).toArray(),i=await("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=i,n):i},l.as(n)}static within(t,e,r=new h(`Operation timed out after ${t}ms`)){return l.as(async n=>{let s;try{return await Promise.race([e(n),new Promise((e,n)=>{s=setTimeout(()=>n(r),t)})])}finally{clearTimeout(s)}})}static retry(t,e=1/0,r=100,n=1,s=1/0){let i=!1;const o=l.as(async o=>{let a=0,c=null;for(;!i&&a<e;)try{const e=await t(o);if(void 0===e)throw new Error("AsyncWhat.retry: undefined result (will retry)");return e}catch(t){c=t;const e=Math.min(r*n**a,s);await new Promise(t=>setTimeout(t,e)),a++}throw i?new Error("Retry stopped by user"):c});return Object.defineProperty(o,"stopped",{get:()=>i,set:t=>{i=Boolean(t)}}),o}}class u{static of(...t){const e=t.slice(0,-1),r=t.at(-1);return u.as((...t)=>f.equal(e,t)?r:void 0)}static as(t){if(t instanceof u)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,u.prototype),e.what=t.bind(e),e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t,e=void 0){return u.retype(u.if(t,this,e),this)}static if(t,e,r=void 0){return u.as((...n)=>{if(t(...n))return e(...n);if(void 0!==r)throw r})}sthen(t){return u.retype(u.sthen(this,t),this)}static sthen(...t){return u.as(e=>{let r=e;for(let e of t)r=e(r);return r})}else(t,e){return t=u.as(t),u.retype((...r)=>{let n;try{n=this(...r)}catch(n){if(!e||c.matches(n,e))return t(...r,n);throw n}return void 0===n?t(...r):n},this)}which(t=t=>void 0!==t,e=u.WHICH_ERROR){return u.retype(u.which(this,t,e),this)}static which(t,e=t=>void 0!==t,r=void 0){return u.as((...n)=>{const s=t(...n);if(e(s,...n))return s;if(void 0!==r)throw r})}when(t,e,r,n=void 0,s=!0){return l.when(t,this,e,r,n,s)}match(...t){return u.retype(u.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return u.as(e)}each(t){return u.retype((...e)=>f.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return u.as(e=>{const r=e instanceof o?e:o.of(e);return r.length>t.length?f.of():r.across(f.as(u.as(t[r.length-1])(r.last)).which()).which()})}self(...t){return u.retype(u.self(this,...t),this)}static self(t,...e){let r;if(0===e.length)return r=e=>e.across(f.as(t(e.last)).which().toArray()),u.as(r);if("number"!=typeof e[0]){const[r,n]=e;return u.nominal(t,r,n)}if(2===e.length){const[r,n]=e;return u.partial(t,r,n)}return l.self(t,...e)}static partial(t,e,r){return u.as((...n)=>t(...n.slice(0,e),r,...n.slice(e)))}static nominal(t,e,r){let n;return n=void 0===e?(...e)=>{const n=t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:n=>{const s=f.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t).toArray(),i=("string"==typeof t?n[t]:t)(...s);return void 0!==r?(n[r]=i,n):i},u.as(n)}}class f{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return f.of();if(t instanceof f)return t;if(t[Symbol.iterator]){const e=new f;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new f;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new f;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new f;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return f.equal(this,t)}static equal(t,e){if("string"==typeof t||!f.isIterable(t)||"string"==typeof e||!f.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!f.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return f.if(this,t)}static if(t,e=t=>void 0!==t){return f.which(t,e)}sthen(t){return f.sthen(this,t)}static sthen(t,e){const r=new f;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?f.else(this):f.else(f.of(this,f.as(t)))}static else(t){const e=new f;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return f.which(this,t)}static which(t,e=t=>void 0!==t){const r=new f;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return f.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},a.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new f;return s[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let i of t)s?yield i:e(i,r)&&(s=!0,n&&(yield i)),r++}:function*(){let r=0,s=!1;for(let i of t){if(s)break;e(i,r)?(s=!0,n&&(yield i)):yield i,r++}},s}match(t=this){return f.match(this,t)}static match(...t){const e=new f;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t){for(const t of this);return}const e=this,r=new f;return r[Symbol.iterator]=function*(){for(const r of e)for(const e of f.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),u.as(e=>e.length<t.length?e.across(t[e.length]):f.of())}self(){return f.self(this)}static self(t){const e=new f;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return f.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=f.what(t),t=f.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}f.NATURAL=new f,f.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class y extends f{start;space;queue;max;constructor(t=void 0,e=void 0,r=void 0,n=void 0){super(),this.start=t,this.space=e,this.queue=r,this.max=n}from(...t){return this.start=t,this}through(t){return this.space=t,this}via(t,e=void 0){return this.queue=t,void 0!==e&&(this.max=e),this}*[Symbol.iterator](){const t=this.queue,e=this.space,r=f.as(this.start),n=this.max;for(t.clear(),t.addAll(r);t.n()>0;){const r=t.poll();let s;try{s=e(r)}catch(t){throw new Error(`Search expansion failed at item: ${r}\n${t}`)}void 0!==s&&(t.addAll(f.as(s)),void 0!==n&&t.select(n)),yield r}}}class d extends a{start;space;queue;max;cores;constructor(t=void 0,e=void 0,r=void 0,n=void 0,s=16){super(),this.start=t,this.space=e,this.queue=r,this.max=n,this.cores=s}from(...t){return this.start=t,this}through(t){return this.space=t,this}via(t,e=void 0){return this.queue=t,void 0!==e&&(this.max=e),this}inParallel(t){return this.cores=t,this}async*batchIterator(){const t=this.queue,e=this.space,r=this.start,n=this.max,s=this.cores;for(t.clear(),t.addAll(await a.as(r).toArray());t.n()>0;){const r=t.select(t.n()-s,!1);let i;try{const t=await Promise.all(r.map(e));i=(await a.as(t).toArray()).flat()}catch(t){throw new Error(`AsyncSearch expansion failed at batch: ${JSON.stringify(r)}\n${t}`)}t.addAll(i),void 0!==n&&t.select(n),yield r}}async*[Symbol.asyncIterator](){for await(const t of this.batchIterator())for(const e of t)yield e}}class p extends f{constructor(){super()}n(){throw new Error("Abstract method: n()")}has(t){throw new Error("Abstract method: has(item)")}add(t){throw new Error("Abstract method: add(item)")}remove(t){throw new Error("Abstract method: remove(item)")}clear(){throw new Error("Abstract method: clear()")}get(t){throw new Error("Abstract method: get(query)")}[Symbol.iterator](){throw new Error("Abstract method: Symbol.iterator()")}create(t){return!this.has(t)&&this.add(t)}read(t){return this.has(t)?f.as(this.get(t)).what():void 0}readAll(t){return this.get(t)}update(t,e,r=!1){return this.has(t)?this.remove(t)&&this.add(e):!!r&&this.add(e)}delete(t){return this.remove(t)}deleteAll(t){return this.removeAll(t)}query(t){return this.get(t)}get size(){return this.n()}isEmpty(){return 0===this.n()}let(t){return this.add(t),this}addAll(t){const e=[];for(const r of t)this.add(r)&&e.push(r);return this}removeAll(t){const e=[];for(const r of t)this.remove(r)&&e.push(r);return e}}Symbol.asyncIterator;class m extends p{constructor(){super()}peek(t=!0){throw new Error("Abstract method: peek() must be implemented by subclass.")}poll(t=!0){const e=this.peek(t);return this.remove(e),e}reverse(){throw new Error("Abstract method: reverse() must be implemented by subclass.")}select(t,e=!0){t<0&&(t=0);const r=this.n()-t,n=new Array(r<0?0:r).fill(void 0);let s=e?n.length-1:0;const i=e?-1:1;for(;this.n()>t;){const t=this.poll(!e);n[s]=t,s+=i}return n}}class v extends m{constructor(t=!0,e=[]){super(),this._fifo=t,this._items=e}get fifo(){return this._fifo}get items(){return this._items}n(){return this.items.length}has(t){return!1}add(t){return this.items.push(t),!0}remove(t){return!1}peek(t=!0){return this.items[this.index(t)]}poll(t=!0){return 0===this.index(t)?this.items.shift():this.items.pop()}index(t){return this.fifo?t?0:this.items.length-1:t?this.items.length-1:0}clear(){return this.items.length=0,!0}[Symbol.iterator](){return this.items[Symbol.iterator]()}reverse(){const t=new f,e=this;return t[Symbol.iterator]=function*(){let t=e.items.length-1;for(;t>=0;)yield e.items[t],t--},t}select(t,e=!0){t<0&&(t=0);const r=e?t:0,n=Math.max(0,this.items.length-t);return this.items.splice(r,n)}}const w={ASCENDING:(t,e)=>t<e?-1:t===e?0:1,DESCENDING:(t,e)=>t<e?1:t===e?0:-1,INSERTION:void 0,SINGULAR:(t,e)=>0,BY_PROPERTY:(t,e=w.ASCENDING)=>(Array.isArray(t)||(t=[t]),Array.isArray(e)||(e=[e]),(r,n)=>{for(let s=0;s<t.length;s++){const i=t[s],o=r[i],a=n[i],c=(e[s]||e[e.length-1])(o,a);if(0!==c)return c}return 0}),REVERSE:t=>(e,r)=>-t(e,r)},b=(t,e)=>()=>[t,e];class g extends v{constructor(t=w.ASCENDING,e=[]){super(!0,[]),this._comparator=t,this._items=[];for(const t of e)this.add(t)}get items(){return this._items}get comparator(){return this._comparator}has(t){const[e,r]=g.logSearch(t,this.items,this.comparator);return void 0!==r}add(t){const[e,r]=g.logSearch(t,this.items,this.comparator);return void 0===r&&(this.items.splice(e,0,t),!0)}remove(t){const[e,r]=g.logSearch(t,this.items,this.comparator);return void 0!==r&&(this.items.splice(e,1),!0)}static logSearch(t,e,r,n=0,s=e.length){for(;n<s;){const i=n+s>>>1,o=r(e[i],t);if(0===o)return[i,e[i]];o<0?n=i+1:s=i}return[n,void 0]}}class S extends m{constructor(t=b(w.ASCENDING,w.INSERTION),e=null,r=void 0){super(),this.parent=e,this.key=r,this.sorter=t,this.depth=(e?.depth??-1)+1,this.nin=0,this.nout=0;const[n,s]=t(this);this.sortedKeys=new g(n),this.keyToChild=new Map,this.class="function"==typeof s?new g(s):new v(s)}getChild(t,e=!1){let r=this.keyToChild.get(t);return!r&&e&&(r=new S(this.sorter,this,t),this.keyToChild.set(t,r),this.sortedKeys.add(t)),r}with(t,e=!1){let r=this;for(const n of f.as(t))if(r=r.getChild(n,e),!r)return;return r}increment(t=1){this.nin+=t;let e=this.parent;for(;e;)e.nout+=t,e=e.parent}pruneIfEmpty(){let t=this;for(;t.parent&&0===t.nin&&0===t.nout;){const e=t.parent;e.keyToChild.delete(t.key),e.sortedKeys.remove(t.key),t.parent=null,t.depth=0,t=e}}n(){return this.nin+this.nout}get size(){return this.nin+this.nout}has(t){const e=this.with(t);return void 0!==e&&e.nin>0}add(t,e,r=1){const n=this.with(t,r>0);if(!n)return!1;const s=n.class.add(e);return n.increment(r),n.pruneIfEmpty(),s}remove(t,e=1/0){const r=this.with(t);return!!r&&(r.increment(-Math.min(e,r.nin)),r.pruneIfEmpty(),!0)}clear(){this.nin=0,this.nout=0,this.sortedKeys.clear(),this.keyToChild.clear(),this.class.clear(),this.pruneIfEmpty()}get(t,e=!0){return f.else(this.descendants(t,e).sthen(t=>e?t.class:t.class.reverse()))}reverse(){return this.get([],!1)}peek(t=!0){return this.get([],t).what()}path(){return this.parent?this.parent.path().add(this):new o}*[Symbol.iterator](){yield*this.get([],!0)}children(t=!1){return t?this.sortedKeys.sthen(t=>this.keyToChild.get(t)):f.as(this.keyToChild.values())}descendants(t=[],e=!0,r=0){Array.isArray(t)||(t=f.as(t).toArray());const n=this,s={*[Symbol.iterator](){const s=e?n.sortedKeys:[...n.sortedKeys].reverse(),i=t[r];for(const o of s){if(void 0!==i&&o!==i)continue;const s=n.keyToChild.get(o);s&&(yield s,yield*s.descendants(t,e,r+1))}}};return f.as(s)}keys(){const t=this,e={*[Symbol.iterator](){for(const e of t.descendants())e.nin>0&&(yield e.path().toArray().map(t=>t.key))}};return f.as(e)}values(){const t=this,e={*[Symbol.iterator](){for(const e of t.descendants())for(const t of e.class)yield t}};return f.as(e)}entries(){const t=this,e={*[Symbol.iterator](){for(const e of t.descendants()){if(e.nin<=0)continue;const t=e.path().toArray().map(t=>t.key);for(const r of e.class)yield[t,r]}}};return f.as(e)}}Symbol.iterator;class E extends i{chronology;stopped=!0;currentPartition;constructor(t,e,r,n,s,i=1/0,o=1){super(),this.pop0=t,this.popSize=e,this.generator=r,this.partitioner=n,this.itemComparator=s,this.maxSteps=i,this.maxChronology=o,this.classifier=new S(b(w.ASCENDING,s)),f.as(t).sthen(t=>this.classifier.add("pop0",t)).each(),this.chronology=new S(b(w.ASCENDING,s)),f.as(t).sthen(t=>this.chronology.add(0,t)).each(),this.currentPartition=void 0}run(){this.stopped=!1,this.emit("start",E.PHASE.RACE,this);for(let t=0;t<this.maxSteps;t++){const e=this.chronology.get(t).class;if(this.stopped||0===e.n())break;this.emit("start",E.PHASE.STEP,this,t),this.chronology.remove(t-this.maxChronology);const r=new S(b(w.ASCENDING,this.itemComparator));for(const t of this.classifier.descendants()){this.currentPartition=t,this.emit("start",E.PHASE.POP,this,t,r);for(const e of t.class){const t=this.generator(e);for(const e of t){const t=this.partitioner(e);r.add(t,e)}}if(this.emit("end",E.PHASE.POP,this,t,r),this.currentPartition=void 0,this.stopped)break}for(const e of r.descendants()){e.class.select(this.popSize);for(const r of e.class)this.chronology.add(t+1,r)}if(this.chronology.get(t+1).class.select(this.popSize),this.classifier=r,this.emit("end",E.PHASE.STEP,this,t),this.stopped)break}return this.emit("end",E.PHASE.RACE,this),this}static PHASE={RACE:"race",STEP:"step",POP:"pop"}}return n})());